
\section{Haskell Optimizations}\label{sec:haskell}
In \cite{Harper2011}'s work there were still multiple open questions left regarding the exact mechanics of what Church and Cochurch encodings did while making their way through the compiler. Why are Cochurch encodings faster in some pipelines, but slower in others? etc.

In this section I'll describe my work replicating the fused Haskell code of the \cite{Harper2011}'s work and further optimization opportunities that were discovered along the way.

\subsection{Church encodings}
\subsection{Cochurch encodings}



\iffalse
One question that comes up is: Yes this fusion is nice, but how does the fused code actually provide a speedup, isn't the language already lazy and therefore not ripe for such a speedup? What are Haskell's other optimizations that come into play that pushes the shortcut fusion over the finish as a fast optimization?
\fi




