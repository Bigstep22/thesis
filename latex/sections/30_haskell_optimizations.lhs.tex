
\section{Haskell Optimizations}\label{sec:haskell}
In \cite{Harper2011}'s work there were still multiple open questions left regarding the exact mechanics of what Church and Cochurch encodings did while making their way through the compiler. Why are Cochurch encodings faster in some pipelines, but slower in others?

In this section I'll describe my work replicating the fused Haskell code of the \cite{Harper2011}'s work and further optimization opportunities that were discovered along the way.

I'll start off with the existing working code, followed by a discussion of the discoveries made throughout the process of writing, replicating, and further optimization of \cite{Harper2011}'s example code.

\subsection{Replicated Code}
%include haskell/leaf_trees.lhs
%include haskell/list.lhs


\subsection{Discussion of code}
Throughout the development process I made use of the tool tastybench\footnote{\url{https://hackage.haskell.org/package/tasty-bench}} and analyzed the dumped core representation generated by GHC\footnote{\url{https://downloads.haskell.org/ghc/latest/docs/users_guide/debugging.html\#core-representation-and-simplification}}.
The process went through the following steps:
\begin{itemize}
    \item Implement List Church encoding
    \item Modify type to make the list `nullable', such that filter can be implemented as a natural transformation.
    \item Implement Leaf Tree Church encoding.
    \item Analyze core representation of (partially) fused list functions. Notice that (co)recursion principle for the function pipelines ends up being the recursion structure that ends up being represented in the Core repesentation.
    \item Modify sum function to be tail-recursive for Cochurch encodings. Notice 40\% speedup.
\end{itemize}
\subsubsection{Implementation Considerations}
\subsubsection{Limitations of Natural Transformation}
% What is the difference between an algeabra, coalgebra, transformation, and natural transformation?
When replicating \cite{Harper2011}'s code for lists, I ran into one major hurdle:
How to represent filter as a natural transformation for both Church and Cochurch encodings?
In his work he implemented, using Leaf trees, a natural transformation for the filter function in the following manner:
\begin{code}
filt :: (a -> Bool) -> Tree_ a c -> Tree_ a c
filt p Empty_ = Empty_
filt p (Leaf_ x) = if p x then Leaf_ x else Empty_
filt p (Fork_ l r) = Fork_ l r
filter2 :: (a -> Bool) -> Tree a -> Tree a
filter2 p = fromCh . natCh (filt p) . toCh
filter3 :: (a -> Bool) -> Tree a -> Tree a
filter3 p = fromCoCh . natCoCh (filt p) . toCoCh
\end{code}
This \tt{filt} function was then subsequently used in the Church and Cochurch encoded function.
Let's try this for the \tt{List} datatype:
\begin{code}
filt :: (a -> Bool) -> List_ a c -> List_ a c
filt p Nil_ = Nil_
filt p (Cons_ x xs) = if p x then Cons_ x xs else ? 
\end{code}
The question is, what should be in the place of the \tt{?} above?
Initially you might say \tt{xs}, as the \tt{Cons\_ x} part should be filtered away, and this would be conceptually correct except for the fact that \tt{xs} is of type \tt{c}, and not of type \tt{List\_ a c}.
Filling in \tt{xs} gives a type error.
Let's change the type annotation then, right?
Well no, if we did that we wouldn't have the type of a transformation anymore, so we can't do that either.

There are two solutions:
One that modifies the definition of \tt{filter2} and \tt{filter3}, such that the definition is still possible, without leveraging transformations.
The other modifies the definition of the underlying type such that the filter function is still possible to express as a transformation.
    
\paragraph{Church}
% Solved using a build/foldr pair - this is true, but how to make the reader see it? 0_o
Whereas before we wanted to implement our \tt{filter} function in the following manner:
\begin{code}
filterCh :: (forall c . List_ a c -> List_ b c) -> ListCh a -> ListCh b
filterCh p (ListCh g) = ListCh (\a -> g (a . (filt p)))
filter2 :: (a -> Bool) -> List a -> List a
filter2 p = fromCh . filterCh p . toCh
\end{code}
We now need to modify the \tt{filterCh} function such that we can still express a filter function \textit{witout} using a natural transformation:
\begin{code}
filterCh :: (forall c . List_ a c -> List_ b c) -> ListCh a -> ListCh b
filterCh p (ListCh g) = ListCh (\a -> g ?)
\end{code}
Replacing the \tt{?} above such that we apply the \tt{a} selectively we can yield:
\begin{code}
filterCh :: (a -> Bool) -> ListCh a -> ListCh a
filterCh p (ListCh g) = ListCh (\a -> g (\case
    Nil_ -> a Nil_
    Cons_ x xs -> if (p x) then a (Cons_ x xs) else xs
  ))
\end{code}
Notice how we do not apply \tt{a} to \tt{xs}, and, in doing so, can put \tt{xs} in the place where wanted to.
The definition of \tt{filterCh} was too restrictive in always postcomposing \tt{a}.

% The astute observer will note that this is just a beta reduced form of a build/foldr composition pair. This begs the question:
% Is it worth rewriting my entire list and leaf trees implementation in terms of foldr and build to drive this point home?
% This will also make extremely apparent the connection between Harper's work and the earlier works on foldr/build and destroy/unfoldr fusion.

% https://hackage.haskell.org/package/ghc-internal-9.1001.0/docs/src//GHC.Internal.Base.html
% My word what a mess...
% mapFB is litery just function composition, but with 4 extra steps
% There has to be a better way :,(

% I was just reading this: https://link.springer.com/chapter/10.1007/978-3-540-30477-7_22
% This is one of the fusion rules that is leveraged in GHC.List fusion.
% Interesting read.

% If we think back to the techniques described by \cite{Gill1993}, we can express \tt{filter} as a \tt{build} followed by a \tt{fold}

\paragraph{Cochurch}
% Solved by implementing a recursive function instead of an algebra
Whereas before we wanted to implement our \tt{filter} function in the following manner:
\begin{code}
filter3 :: (a -> Bool) -> List a -> List a
filter3 p = fromCoCh . natCoCh (filt p) . toCoCh
\end{code}
% Idea is, we combine the transformation and postcomposition again, but this time we make the function recursively grab elements from the seed until we find one.


\paragraph{Third solution: modify the underlying type}
We can add a new constructor to the datatype that allows us to null out the value of our datatype: \tt{ConsN\_ xs}.
This way we can write the \tt{filt} function in the following fashion:
\begin{code}
filt :: (a -> Bool) -> List_ a c -> List_ a c
filt p Nil_ = Nil_
filt p (ConsN_ xs) = ConsN_ xs
filt p (Cons_ x xs) = if p x then Cons_ x xs else ConsN_ xs
\end{code}
Oh, now we do need to modify all of our already defined functions to take into account this modified datatype.
The astute among you might say ``hey, isn't this stream fusion?''.
To which I say yes, yes it is as described by \cite{Coutts2007}.
It is analogous to the \tt{Skip} constructor.

So why was it possible to implement \tt{filt} without modifying the datatype of leaf trees?
Because leaf trees already have this consideration of being able to null the datatype in-place by chaning a \tt{Leaf\_ x} into an \tt{Empty\_}.
\tt{filt} is able to remove a value from the datastructure without changing the structure of the data. I.e. it is still a transformation.
By chaning the list datatype such that this nullability is also possible, we can also write \tt{filt} as a transformation.

This insight is broader than just stream fusion.
By modifying your datatype, you can broaden what can be expressed as a transformation.


\subsubsection{Join point optimization}\label{sec:join}
\subsubsection{The strength of cochurch encodings: tail recursion}\label{sec:tail}
Story of how, through analyzing the core representation and working through and example of the Church and Cochurch encoding by hand enabled the discovery that the corecursion principle ends up being the final function.
If this corecursion principle is tail-recursive, so will the final function.

\subsection{Performance Comparison}



\iffalse
I analyzed the core representation:
- Leaf trees don't fuse nicely for the functions given
- Lists don't fuse nicely due to filter not fusing. Two solutions:
    - Join point optimization: In Haskell this should've worked already, but doesn't :(
    - Make the cons constructor 'skippable'. This way we can implement filter as a natural transformation. Filter now fuses nicely.
- Now that everything is fused, there is still one potential optimization remainin for the core representation: Tail recursion.
    - The (co)recursion principle that get defined for (co)church encodings, can sometimes be rewritten to be tail recrusive.
    - For Cochurch encodings this seems to be easier in some cases. Especially when working with functions that can calculate a result.
    - For Church encodings this is harder, as we need to make an accumulator that stores a part of the data structure that can later be expanded.
\fi


