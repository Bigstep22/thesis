
\section{Haskell Optimizations}\label{sec:haskell}
In \cite{Harper2011}'s work there were still multiple open questions left regarding the exact mechanics of what Church and Cochurch encodings did while making their way through the compiler. Why are Cochurch encodings faster in some pipelines, but slower in others?

In this section I'll describe my work replicating the fused Haskell code of the \cite{Harper2011}'s work and further optimization opportunities that were discovered along the way.

I'll start off with the existing working code, followed by a discussion of the discoveries made throughout the process of writing, replicating, and further optimization of \cite{Harper2011}'s example code.

% \subsection{Replicated Code}
%include haskell/leaf_trees.lhs
%include haskell/list.lhs


\section{Performance Comparison}
PERFORMANCE DISCUSSION


Throughout the development process I made use of the tool tastybench\footnote{\url{https://hackage.haskell.org/package/tasty-bench}} and analyzed the dumped core representation generated by GHC\footnote{\url{https://downloads.haskell.org/ghc/latest/docs/users_guide/debugging.html\#core-representation-and-simplification}}.
The process went through the following steps:
\begin{itemize}
    \item Implement List Church encoding
    \item Modify type to make the list `nullable', such that filter can be implemented as a natural transformation.
    \item Implement Leaf Tree Church encoding.
    \item Analyze core representation of (partially) fused list functions. Notice that (co)recursion principle for the function pipelines ends up being the recursion structure that ends up being represented in the Core repesentation.
    \item Modify sum function to be tail-recursive for Cochurch encodings. Notice 40\% speedup.
\end{itemize}






\iffalse
I analyzed the core representation:
- Leaf trees don't fuse nicely for the functions given
- Lists don't fuse nicely due to filter not fusing. Two solutions:
    - Join point optimization: In Haskell this should've worked already, but doesn't :(
    - Make the cons constructor 'skippable'. This way we can implement filter as a natural transformation. Filter now fuses nicely.
- Now that everything is fused, there is still one potential optimization remainin for the core representation: Tail recursion.
    - The (co)recursion principle that get defined for (co)church encodings, can sometimes be rewritten to be tail recrusive.
    - For Cochurch encodings this seems to be easier in some cases. Especially when working with functions that can calculate a result.
    - For Church encodings this is harder, as we need to make an accumulator that stores a part of the data structure that can later be expanded.
\fi


