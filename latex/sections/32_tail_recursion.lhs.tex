
\subsubsection{Tail Recursion}\label{sec:tail}
The following code, when applying fusion, case-of-case, and case-of-known-case optimization:
\begin{spec}
sumCoCh . mapCoCh (+2) . filterCoCh odd . ListCoCh betweenCoCh
\end{spec}
Reduces to (See \autoref{app:cochurch_stream} for derivation):
\begin{spec}
loop (x, y) = if (x > y)
              then 0
              else if (odd x)
                   then (x + 2) + loop (x+1, y)
                   else -> loop (x+1, y)
loop (x, y)
\end{spec}
If we tweak the definition of sum, such that it is tail recursive we get a different derivation (See \autoref{app:cochurch_tail} for derivation):
\begin{spec}
sumCoCh . mapCoCh (+2) . filterCoCh odd . ListCoCh betweenCoCh
\end{spec}
Reduces to:
\begin{spec}
loop (x, y) acc = if (x > y)
                  then acc
                  else if (odd x)
                       then loop (x+1, y) ((x+2)+acc)
                       else loop (x+1, y)
loop (x, y) 0
\end{spec}
Which is identical except for the fact that \tt{loop} is tail-recursive.
All that has been changed is the recursion principle \tt{su'}.

Cochurch encodings better lend themselves to having fully tail-recursive fused pipelines, as writing a coinduction principle that is tail-recursive is easier than writing a recursion principle that is.
WHY??????????????
