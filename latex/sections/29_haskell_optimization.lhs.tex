\subsection{Haskell's optimization pipeline}
In order to understand how fusion works, it is important to understand a few other concepts that fusion works in tandem with.
Namely, beta reduction, inlining, case-of-case, and tail call optimization.
I will give a brief description of each.

\subsubsection{Beta reduction}
Beta reduction is simply the rule where an expression of the form \tt{($\lambda$ x . a[x]) y} can get transformed into \tt{a[y]}.
For example \tt{($\lambda$ x . x + x) y} would become \tt{y + y}.
\subsubsection{Inlining}
Inlining is the process of taking a function expression and unfolding it into its definition.
If we take the function \tt{f = (+2)} and an expression \tt{f 5}, we could inline \tt{f} such that we get \tt{(+2) 5}; which we could inline again to obtain \tt{5 + 2}.
\subsubsection{Case of case, and known-case elimination}
As discussed by \cite{Jones1996}, case of case optimization is the transformation of the following pattern:
\begin{spec}
case ( 
  case C of 
    B1 -> F1
    B2 -> F2
  ) of
    A1 -> E1
    A2 -> E2
\end{spec}
To the following\footnote{This specific example was retrieved from: \url{https://stackoverflow.com/questions/35815503/what-ghc-optimization-is-responsible-for-duplicating-case-expressions}}:
\begin{spec}
case C of    
  B1 -> case F1 of
    A1 -> E1
    A2 -> E2
  B2 -> case F2 of
    A1 -> E1
    A2 -> E2
\end{spec}
Where the branches of the outer case are pushed into the branches of the inner.
Furthermore:
\begin{spec}
case V of
  V -> Expr
  ...
\end{spec}
Is case-of-known-constructor, we can simplify it to:
\begin{spec}
Expr
\end{spec}
Together, these optimizations can often lead to the removal of unecessary computations. Take as an example \citep{Jones1996}:
\begin{spec}
if (not x) then E1 else E2
\end{spec}
``No decent compiler would actually negate the value of \textbf{x} at runtime! [...] After desugaring the conditional, and inlining the definition of \textbf{not}, we get'' \citep{Jones1996}:
\begin{spec}
case (case x of
  True -> False
  False -> True
) of 
  True -> E1 
  False -> E2
\end{spec}
With case-of-case transformation this gets transformed to:
\begin{spec}
case x of 
  True -> case False of
    True -> El
    False -> E2
  False -> case True of
    True -> El
    False -> E2
\end{spec}
Then the case-of-known-constructor transformation gets us:
\begin{spec}
case x of
  True -> E2
  False -> E1
\end{spec}
No more runtime evaluation of not!


ADD A (LARGE) EXAMPLE AS TO WHY THIS IS SO IMPORTANT FOR THE FUSED PIPELINES


