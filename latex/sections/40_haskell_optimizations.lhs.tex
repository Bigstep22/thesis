
\section{Haskell Optimizations}\label{sec:haskell}
In \cite{Harper2011}'s work there were still multiple open questions left regarding the exact mechanics of what Church and Cochurch encodings did while making their way through the compiler. Why are Cochurch encodings faster in some pipelines, but slower in others? etc.

In this section I'll describe my work replicating the fused Haskell code of the \cite{Harper2011}'s work and further optimization opportunities that were discovered along the way.

I'll start off with the existing working code, followed by a discussion of the discoveries made throughout the process of writing, replicating, and further optimizing \cite{Harper2011}'s example code.

\subsection{Replicated Code}
%include haskell/leaf_trees.lhs
%include haskell/list.lhs


\subsection{Discussion of code}
\subsubsection{Limitations of Church-fusion and perks of stream-fusion}\label{sec:tail}
Lack of explanation on \cite{Harper2011}'s part about choice of leaf trees, how in lists, it is not possible to implement filter as a natural transformation.
\subsubsection{The strength of cochurch encodings: tail recursion}
Story of how, through analyzing the core representation and working through and example of the Church and Cochurch encoding by hand enabled the discovery that the corecursion principle ends up being the final function.
If this corecursion principle is tail-recursive, so will the final function.
\subsubsection{Join point optimization}\label{sec:join}



\iffalse
One question that comes up is: Yes this fusion is nice, but how does the fused code actually provide a speedup, isn't the language already lazy and therefore not ripe for such a speedup? What are Haskell's other optimizations that come into play that pushes the shortcut fusion over the finish as a fast optimization?
\fi




